# Variable Scope

## ==Question # 1==

What will the following code print and why?

```ruby
a = 7

def my_value(b)
  b += 10
end

my_value(a)
puts a
```

**Answer**

The code outputs `7`. 

On line 1,  the local variable `a` is initialized and references the Integer Object `7`.  Integers are immutable Objects.

On line 7, we invoke the `my_value` method with `a` as an argument. Ruby makes a copy of the reference to the integer object 7, which is bound to the method parameter `b`.  Within the method, the method `+` is invoked on the object referenced by `b`, returning the a new Integer object with value `17`, which is then reassigned to `b`. This reassignment of `b` has no effect on the variable `a` in the outer scope. Worth mentioning that `b += 10` is syntactic sugar for `b = b + 10`. The value is implicitly returned by the method, but as it is not reassigned to any variable is then discarded.

On line 8, we invoke the `puts` method with `a` as an argument, outputting `7`.

This code snippet demonstrates object passing strategy, in which Ruby behaves as if "Pass-by-value" as the object passed into the method is immutable. It also demonstrates local variable scope within method definitions. Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. The only way to make the outer scope available to the method is via parameters.
## ==Question # 2==

What will the following code print, and why?

```ruby
a = 7

def my_value(a)
  a += 10
end

my_value(a)
puts a
```

**Answer**

The code outputs `7`. 

On line 1,  the local variable `a` is initialized and references the Integer Object `7`. Integer Objects are immutable.

On line 7, we invoke the `my_value` method with `a` as an argument. Ruby makes a copy of the reference to the integer object 7, which is then bound to the method parameter `a`.  Within the method, the method `+` is invoked on the object referenced by method local variable `a`, returning a new Integer object with value `17`, which is then reassigned to `a`. This reassignment of `a` inside the method has no effect on the variable `a` in the outer scope. Worth mentioning that `a += 10` is syntactic sugar for `a = a + 10`. The value is implicitly returned by the method, but as it is not reassigned to any variable is then discarded.

On line 8, we invoke the `puts` method with `a` as an argument, outputting `7`.

This demonstrates how Ruby treats immutable objects in a way that resembles pass-by-value behavior. It also demonstrates local variable scope within method definitions. Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. The only way to make the outer scope available to the method is via parameters.


## ==Question # 3==

What will the following code print, and why?

```ruby
a = 7

def my_value(b)
  a = b
end

my_value(a + 5)
puts a
```

**Answer**

The code outputs `7`. 

On line 1,  the local variable `a` is initialized and references the Integer Object `7`. Integers are immutable objects.

On line 7, we invoke the method `my_value` with the expression `a + 5` as an argument. The object referenced by `a` is 7, so the expression `a + 5`  is evaluated in the outer scope and returns `12`, which is then bound to the method parameter `b`.

Within the method, on line 4, we initialize the method local variable `a` to `12`, which has no effect on the variable `a` in the outer scope. The value is implicitly returned, and then discarded as it not assigned to any variable.

On line 8, we call the `puts` method with `a` as an argument, outputting `7`.

This demonstrates how Ruby treats immutable objects in a way that resembles pass-by-value behavior. It also demonstrates local variable scope in relation to method definitions. Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. 


## ==Question # 4==

What will the following code print, and why?

```ruby
a = "Xyzzy"

def my_value(b)
  b[2] = '-'
end

my_value(a)
puts a
```

**Answer**

The code outputs `Xy-zy`

On line 1, the local variable `a` is initialized and references a String object with value `Xyzzy`. Strings are mutable.

On line 7, we call the method `my_value` with the object referenced by `a` as an argument.

On lines 1-3 the method `my_value` is defined with a single parameter `b`, which is bound to the object referenced by `a` after the method invocation.

Within the method, the index assignment `b[2] = '-'` operation mutates the object referenced by both `b` and `a` by changing `z` to the string object with value `-`, resulting in the value `Xy-zy`. The value is returned implicitly by the method as is the last expression evaluated.

On line 8, we call the `puts` method with `a` as an argument, outputting `Xy-zy`.

The code snippet demonstrates how Ruby allows mutation of mutable objects in a way that resembles pass-by-reference as the argument was mutated within the method. This code snippet also demonstrates the difference between reassignment (which doesn't affect the original objects) and mutation (which it does).

## ==Question # 5==

What will the following code print, and why?

```ruby
a = "Xyzzy"

def my_value(b)
  b = 'yzzyX'
end

my_value(a)
puts a
```

**Answer**

The code outputs `Xyzzy`.

On line 1, the local variable `a` is initialized and references a String object with value `Xyzzy`. Strings are mutable.

On line 7, we call the `my_value` method with the object referenced by `a` as an argument.

On lines 3-5, we define the method `my_value` with `b` as a parameter, which is
bound to the object referenced by `a` after the method invocation. Ruby passes a reference to the string object, not a copy of the string.

Inside the method, the method local variable `b` is reassigned to a new String object with value `yzzyX`. This reassignment has not effect on the original object referenced by local variable `a`.

On line 8, we call the `puts` method with `a` as an argument, outputting `Xyzzy` as it is the object referenced by local variable `a` initialized on line 1.

This demonstrates how Ruby's treatment of reassignment within methods resembles pass-by-value behavior, even for mutable objects like strings.

## ==Question # 6==

What will the following code print, and why?

```ruby
a = 7

def my_value(b)
  b = a + a
end

my_value(a)
puts a
```

**Answer**

This code raises a `NameError` exception as the Ruby interpreter cannot find any variable `a` within the method's scope. The local variable `a`initialized in the outer scope is not available within the method's body.

On line 1, the local variable `a` is initialized and references the Integer Object with value `7`. Integers are immutable.

The method `my_value` is defined, on lines 3-5, with a parameter `b`.

On line 7, we call the method `my_value` with the object referenced by `a` as an argument, which is bound to the method parameter `b`. 

Inside the method, there's an attempt to reference a method local variable `a`, which is not initialized inside the method nor passed in as a parameter, raising a `NameError` exception, as `a` is not accessible within the method.

On line 8, the `puts` method is called with `a` as an argument. This would have output `7`, if this line were reached, but it won't due to the exception raised in the method call.

This code snippet demonstrates the concept of local variable scope within method definitions. Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. The only way to make the outer scope available to the method is via parameters.

## ==Question # 7==

What will the following code print, and why?

```ruby
a = 7
array = [1, 2, 3]

array.each do |element|
  a = element
end

puts a
```

**Answer**

The code outputs `3`.

On line 1, the local variable `a` is initialized and references the integer object with value `7`.

On line 2, the local variable `array` is initialized and references an array object with 3 Integer Objects with values `[1, 2, 3]`.

On line 4, the `each` method is called on the object referenced by `array` and gets passed a `do..end` block as an argument. This method iterates over each element in the array, passing each element to the block in turn.

Inside the block, the local variable `a` is reassigned to the object referenced by `element` in each iteration, starting with `1`, then `2`and finally `3`. This reassignment affects the outer scope variable `a` because blocks in Ruby can access and modify variables from the outer scope.

On line 8, we call the `puts` method with `a` as an argument, outputting `3`, which is the last value assigned to the local variable `a` within the block.

This code snippet demonstrates the concept of local variable scope in relation to blocks after a method invocation, in which blocks create a new inner scope that can access and modify variables from the outer scope. It also demonstrates the behavior of the `each` method when called on array objects.

## Question # 8

What will the following code print, and why?

```ruby
array = [1, 2, 3]

array.each do |element|
  a = element
end

puts a
```

**Answer**

This code raises a `NameError` exception.

When we call the method `puts` with `a` as an argument, the local variable `a` doesn't exist in the outer scope. The local variable `a` is initialized in an inner scope (inside the block), so it is not accessible in the outer scope.

This code demonstrates the concept of local variable scope in relation to blocks after method invocation.

## Question # 9

What will the following code print, and why?

```ruby
a = 7
array = [1, 2, 3]

array.each do |a|
  a += 1
end

puts a
```

**Answer** (NOTE: I didn't recognize variable shadowing here until I ran the code)

This code outputs `7`

The reason is that the block parameter `a` has the same name as the local variable `a` initialized in the outer scope. This block parameter `a` shadows the local variable `a` in the outer scope preventing its access from within the block.

So the local variable `a` within the block is a different variable from the one in the outer scope, so at the end of the iteration, the value of `a` is `4`.

When we call the `puts` method with `a` as an argument, the output is `7` as this local variable is not affected by the reassignment within the block.

This code snippet demonstrates the concept of variable shadowing.


## Question # 10

What will the following code print, and why?

```ruby
a = 7
array = [1, 2, 3]

def my_value(ary)
  ary.each do |b|
    a += b
  end
end

my_value(array)
puts a
```

**Answer**

This code raises an exception `NoMethodError`

The reason is that in the definition of the `my_value` method, there is no a local variable `a` initialized within the method, and not inside the block, so when we call the method `+` on a object referenced by `a` the exception is raised.

This code snippet demonstrates the concept of variable scope in relation to a method definition and in relation to a block after a method invocation.

## Question #11

What will the following code output and why?

```ruby
x = 10
5.times do |x|
    puts x
end
puts x
```

**Answer**

This code outputs on separate lines the values `0`, `1`, `2`, `3`, `4` and `10`.

On line 1, the local variable `x` is initialized and references the Integer object with value `10`.

On lines 2-3, we call the `times` method on `5` and it gets passed a `do..end` block as an argument. The block parameter `x` has the same name as the local variable `x` initialized in the outer scope, shadowing it and preventing access to `x`  from within the block.

On line 2, we call the `puts` method with `x` as an argument, outputting in each iteration the value referenced by `x`, from `0` to `4` on separate line.

On line 5, we call the `puts` method with `x` as an argument, outputting `10`, as this is the object referenced by `x` in the outer scope.

This code snippet demonstrates the concept of variable shadowing.

## Question #12

What is the output of this code and why?

```ruby
a = 5
3.times do |n|
    a = 3
    b = 5
end
puts a
puts b
```

**Answer** (NOTE: Didn't notice the exception until I ran the code)

This code outputs `3` and raises an exception on line 7.

On line 1, the local variable `a` is initialized and references the integer object `5` as an argument.

On lines 2-5, the `times` method is called on `3` and gets passed a `do..end` block as an argument. The `times` method yields during each iteration a value from `0` to `2` that gets assigned to the block parameter `n`. 

Within the block, `a` is reassigned to `3` and `b` is initialized and references the value `3`.

On line 6, the method `puts` is called with `a` as an argument, outputting `3`

On line 7, the method `puts`is called with `b`as an argument, raising an exception as there is not variable `b` available in the outer scope, as it was initialized inside the block, so it has inner scope.

This code snippet demonstrates the concept of variable scope in relation to blocks after a method invocation.

## Question #13

What will this code output and why?

```ruby
arr = [1, 2, 3]
for i in arr do
    a = 5
end
puts a
```

**Answer**

This code outputs `5`

On line 1, the local variable `arr` is initialized and references an Array Object with 3 elements `[1, 2, 3]`.

On lines 2-4 there is a for loop that iterates over each element of `arr` and initialize a local variable `a` which references the integer object with the value `5`.

On line 5, we call the `puts` method with `a` as an argument, outputting `5`

This code snippet demonstrates that the `for` loop in Ruby is not implemented as a method, so it doesn't create an inner scope within the `do..end` block, so the local variable `a` is available when we invoke the `puts` method as it was initialized in the outer scope.

## ==Question #14==

What is the result of running this code and why?

```ruby
def change_name(name)
    name = 'bob'
end

name = 'jim'
change_name(name)
puts name
```

**Answer**

This code outputs `jim`

On line 5, the local variable `name` is initialized and references a string object with value `jim`. Strings are mutable.

On line 6, we call the `change_name` method with the object referenced by `name` as an argument.

On lines 1-3, the method `change_name` is defined with the parameter `name`, which is bound to `jim`.

On line 2, the method local variable `name` is reassigned to the string object `bob`. This reassignment has not effect on the variable `name` in the outer scope. The value is implicitly returned. As the method returned value `bob` is not used outside the method, it is discarded.

On line 7, we call the `puts`method with `name` as an argument, outputting `jim`.

This demonstrates how Ruby treats reassignment of method parameters in a way that resembles pass-by-value behavior. This example illustrates method definition scope, where variables inside a method are not accessible outside, and variables outside are not directly accessible inside unless passed as arguments.

