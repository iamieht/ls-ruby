# Variable Scope

## Question # 1

What will the following code print and why?

```ruby
a = 7

def my_value(b)
  b += 10
end

my_value(a)
puts a
```

**Answer**

The code outputs `7`. 

On line 1,  the local variable `a` is initialized and references the Integer Object `7`. 

On line 7, we invoke the `my_value` method with `a` as an argument. The value referenced by `a` is bound to the method parameter `b`.  Within the method, the method `+` is invoked on the object referenced by `b`, returning the value `17`, which is then reassigned to `b`. The value is implicitly returned by the method, but as it is not reassigned to any variable is then discarded.

On line 8, we invoke the `puts` method with `a` as an argument, outputting `7`.

This code snippet demonstrates object passing strategy, in which Ruby behaves as if "Pass-by-value" as the object passed into the method is immutable. It also demonstrates local variable scope within method definitions, in this code the method local variable `b` is available only within the method definition.
## Question # 2

What will the following code print, and why?

```ruby
a = 7

def my_value(a)
  a += 10
end

my_value(a)
puts a
```

**Answer**

The code outputs `7`. 

On line 1,  the local variable `a` is initialized and references the Integer Object `7`. 

On line 7, we invoke the `my_value` method with `a` as an argument. The value referenced by `a` is bound to the method parameter `a`.  Within the method, the method `+` is invoked on the object referenced by `a`, returning the value `17`, which is then reassigned to `a`. The value is implicitly returned by the method, but as it is not reassigned to any variable is then discarded.

On line 8, we invoke the `puts` method with `a` as an argument, outputting `7`.

This code snippet demonstrates object passing strategy, in which Ruby behaves as if "Pass-by-value" as the object passed into the method is immutable. It also demonstrates local variable scope within method definitions, in this code the method local variable `a` is a different variable from the one initialized in the outer scope.
## Question # 3

What will the following code print, and why?

```ruby
a = 7

def my_value(b)
  a = b
end

my_value(a + 5)
puts a
```

**Answer**

The code outputs `7`. 

On line 1,  the local variable `a` is initialized and references the Integer Object `7`. 

On lines 3-5, we define the method `my_value` with a parameter `b`.

On line 7, we invoke the method `my_value` with the expression `a + 5` as an argument, which evaluates to `12`. `12` is then bound to parameter `b`.

Within the method, on line 4, we initialize the method local variable `a` to `12`, and return it implicitly, but the value returned is discarded as it not assigned to any variable.

On line 8, we call the `puts` method with `a` as an argument, outputting `7` as `a` refers to the local variable initialized on line 1.

This code snippet demonstrates the concept of object passing, in which Ruby behaves as "pass-by-value" as the object passed into the method is immutable. It also demonstrates local variable scope within method definitions, as the method local variable `a` is a different variable than the one initialized in the outer scope on line 1. 


## Question # 4

What will the following code print, and why?

```ruby
a = "Xyzzy"

def my_value(b)
  b[2] = '-'
end

my_value(a)
puts a
```

**Answer**

The code outputs `Xy-zy`

The reason is that on line 7, we call the method `my_value` with `a` as an argument, which was initialized on line 1 and references the string object with value `Xyzzy`. The value is bound to the method parameter `b`. Within the method, the index assignment `b[2] = '-'` mutates the object referenced by both `b` and `a` by changing the element `z` located at index `2` by the string object with value `-`, resulting in the value `Xy-zy`, which is then returned implicitly.

On line 8, we call the `puts` method with `a` as an argument, outputting `Xy-zy`.

The code snippet demonstrates object passing strategy, in which Ruby behaves as if "Pass-by-Reference" as the String object passed into the method is mutated by an index assignment method.

## Question # 5

What will the following code print, and why?

```ruby
a = "Xyzzy"

def my_value(b)
  b = 'yzzyX'
end

my_value(a)
puts a
```


## Question # 6

What will the following code print, and why?

```ruby
a = 7

def my_value(b)
  b = a + a
end

my_value(a)
puts a
```


## Question # 7

What will the following code print, and why?

```ruby
a = 7
array = [1, 2, 3]

array.each do |element|
  a = element
end

puts a
```


## Question # 8

What will the following code print, and why?

```ruby
array = [1, 2, 3]

array.each do |element|
  a = element
end

puts a
```


## Question # 9

What will the following code print, and why?

```ruby
a = 7
array = [1, 2, 3]

array.each do |a|
  a += 1
end

puts a
```


## Question # 10

What will the following code print, and why?

```ruby
a = 7
array = [1, 2, 3]

def my_value(ary)
  ary.each do |b|
    a += b
  end
end

my_value(array)
puts a
```

### What will the following code output and why?

```ruby
x = 10
5.times do |x|
    puts x
end
puts x
```

### What is the output of this code and why?

```ruby
a = 5
3.times do |n|
    a = 3
    b = 5
end
puts a
puts b
```

### What will this code output and why?

```ruby
arr = [1, 2, 3]
for i in arr do
    a = 5
end
puts a
```

### What is the result of running this code and why?

```ruby
def change_name(name)
    name = 'bob'
end

name = 'jim'
change_name(name)
puts name
```
