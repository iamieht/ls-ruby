# Object Passing/Variables as Pointers

## Question # 1

Explain the concept of "Variables as Pointers". As part of your explanation, include a code snippet that accurately demonstrates this concept, and explain the effect it has within that example.

**Answer**

Variables don't contain values, they contain pointers to a physical space in memory, that store values. Variables are not deeply linked to each other.

```ruby
name = "Ivan"
my_name = name
name = "María"

puts name
puts my_name
```

On line 1, we initialized the variable `name` to reference the string object with value `"Ivan"`. On line 2, we initialized the variable `my_name` to reference the same object as variable `name`. On line 3, we reassign the variable `name` to the string object `"María"`.

On line 5, the `puts` method is invoked and gets passed the object referenced by variable `name` as an argument. As variable `name` references the string object with value `"María"`, this is output into the console. 

On line 6, the `puts` method is invoked and gets passed the object referenced by variable `my_name` as an argument, outputting the value `"Ivan"` to the console.

This code snippet demonstrates the concept of variables as pointers.


## Question # 2

What is the output of this code? Why? 

```ruby
a = "hi there"
b = a
a = "not here"

puts a
puts b
```

**Answer**

On line 1, the variable `a` is initialized and references the string object with value `"hi there"`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, `a` is reassigned and references the string object with value `"not here"`.

On line 5, the `puts` method is invoked and gets passed the value `"not here"`referenced by the variable `a`, outputting it to the console.

On line 6, the `puts` method is invoked and gets passed the value `"hi there"` referenced by the variable `b`, outputting it to the console.

This code snippet demonstrates the concept of variables as pointers and how variables are not deeply linked to each other.

## Question # 3

What is the output of this code? Why? 

```ruby
a = "hi there"
b = a
a << ", Bob"

puts a
puts b
```

**Answer**

On line 1, the variable `a` is initialized and references the string object with value `"hi there"`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, the method `#<<` is invoked on string object `"hi there"`, passing the string object with value `", Bob"` as an argument. This is a mutating method, so the object referenced by variable `a` is modified with the value `"hi there, Bob"`.

On line 5, the `puts` method is invoked and gets passed the string object with value `"hi there, Bob"` referenced by variable `a`, outputting it to the console.

On line 6, the `puts` method is invoked and gets passed the string object with the same value `"hi there, Bob"` which is also referenced by the variable `b`.

This concept demonstrates variables as pointers and mutation.

## Question # 4

What is the output of this code? Why? 

```ruby
a = [1, 2, 3, 3]
b = a
c = a.uniq

puts a
puts b
```

On line 1, the variable `a` is initialized and references an Array object with value `[1, 2, 3, 3]`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, the variable `c` is initialized and references the return value of the `uniq` method invocation on the object referenced by variable `a`. The `uniq` method is a non-destructive method, so a new Array object with value `[1, 2, 3]` is returned and assigned to the variable `c`. This has no effect on the object referenced by variables `a` and `b`.

On line 5, the `puts` method is invoked and gets passed the object referenced by `a`, outputting the value `1, 2, 3, 4` to the console.

On line 6, the `puts` method is invoked and gets passed the value referenced by `b` as an argument, outputting `1, 2, 3, 3` to the console, a both `a` and `b` are referencing the same object in memory.

This code demonstrates variables as pointers and how variables are not deeply linked to each other.


## Question # 5

Are `a` and `b` referencing the same object? Why? What is `a`? What if we called `map!` instead of `map`?

```ruby
def test(b)
  b.map { |letter| "I like the letter: #{letter}" }
end

a = ['a', 'b', 'c']
test(a)
```

Yes, `a` and `b` are referencing the same object.

On line 4, local variable `a` is initialized and references the Array Object with value `['a', 'b', 'c']`.

On line 5, the `test` method is invoked and gets passed the object referenced by local variable `a` , which is then bound to the parameter `b` of the `test` method. At this point both local variable `a` and method local variable `b` are referencing the same object in memory.

From lines 1-3, the `test` method is defined with a single parameter `b`. Within the method's body, the `Array#map` method is invoked on the object referenced by `b`and gets passed a block as an argument. Within the block, the parameter `letter` is assigned to each element of the array object and the string object with value `"I like the letter: #{letter}"` is returned, interpolating the value of the variable `letter` within the string object. A new array object is returned by the `Array#map` method invocation, as it is not a destructive method, so after each iteration, a new array with the values `["I like the letter: a", "I like the letter: b", "I like the letter: c"]`is returned by the method as is the only line evaluated.

As the returned value from the method is not stored anywhere, the value is lost, so `a` still references the same Array object  with value `["a", "b", "c"]`.

This code snippet demonstrates the concept of object passing, in which Ruby behaves as "pass-by-value" as the original object is not mutated.

In case we called the method `map!` the original object will be mutated and now the variable `a` will reference the value `["I like the letter: a", "I like the letter: b", "I like the letter: c"]`. In this case the object passing strategy behaves like "pass-by-reference" as the original object is mutated.

## Question # 6

What is the output of this code? why?

```ruby
a = 5.2
b = 7.3
a = b
b += 1.1

puts a
puts b
```

**Answer**

This code outputs `7.3` and `8.4`

On line 1, the variable `a` is initialized and references the Integer Object with value `5.2`. On line 2, the variable `b` is initialized and references the value `7.3`. On line 3, the variable `a` is reassigned to the same value referenced by  `b`. On line 4, the method `#+` is invoked on the object referenced by `b` and gets passed `1.1` as an argument. The return value `8.4` is then reassigned to the variable `b`. As we are working with immutable objects, the return values of any method invocation will result in a new object being created.

On line 6, the `puts` method is invoked and gets passed the value referenced by `a` as an argument, outputting `7.3` to the console.

On line 7, the `puts`method is invoked and gets passed the value referenced by `b` as an argument, outputting `8.4`to the console.

This code snippet demonstrates the concept of variables as pointers and how variables are not deeply linked to each other.

## Question # 7

What is the output of this code? why?

```ruby
def test(str)
  str  += '!'
  str.downcase!
end

test_str = 'Written Assessment'
test(test_str)

puts test_str
```

**Answer**

The output is `Written Assessment`.

On line 6, the local variable `test_str` is initialized and references the string object with value `Written Assessment`.

On line 7, the `test` method is invoked and gets passed the value referenced by `test_str` as an argument. The value is then bound to the method parameter `str`.

Within the method's body, the method `#+` is invoked on the value referenced by method local variable `str` and gets passed the string object with value `!` as an argument. A new string object is created with the value `Written Assessment!` as return value of the method invocation, reassigning it to the variable `str`. On line 3, the method `downcase!` is invoked on the value referenced by method local variable `str` mutating the caller, which new value is now `written assessment!`. As this is the last evaluated expression in the method, there is an implicit return call.

As the return value of the `test` method invocation is not stored anywhere, the value is lost.

On line 9, the `puts` method is invoked and gets passed the value referenced by `test_str` as an argument, which references the string object with value `"Written Assessment"` , which is then output into the console.

This code snippet demonstrates object passing strategy and here Ruby behaves as "Pass-by-value", as the object passed into the method is not mutated, so the original object remains unchanged.



## Question # 8

What is the output of this code? why?

```ruby
def plus(x, y)
  x = x + y
end

a = 3
b = plus(a, 2)

puts a
puts b
```

**Answer**

The output is `3` and `5`.

On line 5, the local variable `a` is initialized and references the integer object with value `3`.

On line 6, the local variable `b` is initialized to the return value of the `plus` method invocation. `plus` is invoked and gets passed the value `3` referenced by local variable `a` and the integer object `2` as an argument.

From lines 1-3, the method `plus` is defined and the parameters `x` and `y` are bound to the object with values `3`and `2` respectively. 

Within the method's body, the expression `x + y` is evaluated to the value `5` and reassigned to the method local variable `x`, which is then implicitly returned by the method, as it is the last line evaluated.

The value `5` is assigned to the local variable `b` on line 6.

On line 8, the `puts` method is invoked and gets passed the value referenced by local variable `a`, outputting `3` to the console.

On line 9, the `puts` method is invoked and gets passed the value referenced by local variable `b`, outputting `5` to the console.

This code snippet demonstrates object passing, and as the objects passed into the method as immutable, the object passing strategy behaves as "pass-by-value".


## Question # 9

What do you think the output of this code will be when we call `puts y` at the end? And can you explain why?

```ruby
def increment(x)
  x << 'b'
end

y = 'a'

increment(y)
puts y
```

**Answer**

The output of this code is `ab`.

On line 5, the local variable `y` is initialized and references the string object with value `a`.

On line 7, the method `increment` is invoked and gets passed the object referenced by `y` as an argument, which is bound to the method parameter `x`.

From lines 1-3 the method `increment` is defined. Within the method's body, the method `#<<` is invoked on the object `a`referenced by method local variable `y`and gets passed the string object `b` as an argument. This method mutates the caller, which now has the value `ab`. So the value referenced by `y` and `x` has changed. As this is the last line evaluated in the method, there is an implicit return call.

On line 8, the `puts` method is invoked and gets passed the value referenced by `y` as an argument, outputting `ab` to the console.

This code snippet demonstrates object passing in which Ruby behaves as "pass-by-reference", as the original object passed into the method is mutated, being an example of a method with side effects.


This question relates to concepts covered in the RB101 course, specifically dealing with object mutability, method side effects, and how Ruby handles string objects when passed to methods.


## Question # 10

Does this reassignment `name = 'bob'` change the object outside the method?

```ruby
def change_name(name) 
   name = 'bob'      
end

name = 'jim'
change_name(name)

puts name
```

**Answer**

No.

When invoking the `change_name` method and pass in the value referenced by local variable `name`, the value is bound to the method parameter `name`. Within the method's body, `name` is reassign to a new string object with value `bob`, and as reassignment (`#=`) is a non-mutating method, the original object referenced by local variable `name`is not changed. 

In this code snippet there are 2 different `name` variables, a local variable and a method local variable, both referencing different objects.

This code snippet demonstrates object passing, in which Ruby behaves as "pass-by-value" and local scoping rules within method definitions, as methods have self-contained scope, so the method local variable `name` has no reference to local variable `name`in the main scope.



## Question # 11

Does `str.capitalize!` affect the object outside the method?

```ruby
def cap(str) 
    str.capitalize!   # 
end

name = "jim"
cap(name)
puts name
```

**Answer**

Yes it does.

On line 6, the `cap` method is invoked and gets passed the object referenced by local variable `name` as an argument. The value `jim` is bound to the method parameter `str` and within the method's body, the mutating method `capitalize!` is invoked on the value `jim` referenced by method local variable `str`. The local variable `name` and the method local variable `str` are referencing the same object, which is now mutated referencing the value `Jim`.

On line 7, the `puts` method is invoked and gets passed the value `Jim` referenced by local variable `name`, as an argument, outputting `Jim`to the console.

This code snippet demonstrated object passing, in which Ruby behaves as is "Pass-by-reference".



## Question # 12

What is the output of this code? why?

```ruby
a = [1, 3]
b = [2]
arr = [a, b]
arr[1] = 5

p arr
```

**Answer**

On line 1, local variable `a` is initialized and references the Array object with value `[1, 3]`.

On line 2, local variable `b` is initialized and references the Array object with value `[2]`.

On line 3, local variable `arr` is initialized and references an Array Object with two elements. The first element `a` references the object `[1, 2]`and second element `b` references the array object `[2]`. At this point variable `arr = [[1, 3], [2]]`.

On line 4, an index assignment method `#[]`is invoked on element with index 1 and gets passed the integer object with value `5` as an argument, mutating the Array by replacing the nested Array object `[2]` with `5`.

On line 6, the `p` method is invoked and gets passed the object referenced by `arr` returning and outputting `[[1,3], 5]` to the console.

This code snippet demonstrates mutation on Array objects and variables as pointers.



## Question # 13

What will be the values of `arr1` and `arr2` after this code is executed? Can you explain why?

```ruby
arr1 = ["a", "b", "c"]
arr2 = arr1.dup

arr2.map! do |char| 
    char.upcase
end

puts arr1
puts arr2
```

**Answer**

The value of `arr1` is `["a", "b", "c"]` and the value of `arr2` is `["A", "B". "C"]`

On line 1, local variable `arr1` is initialized and references the array object with value `["a", "b", "c"]`.

On line 3, local variable `arr2` is initialized and references the return value of the `dup` method invocation on `arr1`. `arr2` references a new array object that contains the same values as `arr1`.

On line 4, the `map!` method is invoked on the Array object referenced by `arr2` and gets passed a `do..end` block as an argument. The values yield by the `map!` method invocation are assigned to the block parameter `char` and the `upcase` method is invoked on the value referenced by `char` mutating the value and returning it uppercased. After the 3 iterations, the array object is referencing the values `["A", "B", "C"]. 

On line 8, the `puts` method is invoked and gets passed the value referenced by `arr1`, outputting `a b c` to the console.

On line 9, the `puts` method is invoked and gets passed the value referenced by `arr2`, outputting `A B C` to the console.

This code snippet demonstrates mutability and method invocation with blocks.


This question relates to concepts covered in the RB101 course, specifically dealing with object duplication, mutability of arrays and strings, and the behavior of the `map!` method in Ruby.


## Question #14

What is the output of this code? why?

```ruby
a = [1, 2, 3]
b = a
b << 4
puts a.inspect
```

**Answer**

The output of this code is `[1, 2, 3, 4]`

On line 1, local variable `a` is initialized and references array object with value `[1, 2, 3]`

On line 2, local variable `b` is initialized and references the same object as `a`

On line 3, method `#<<`is invoked on the value referenced by `b` and gets passed `4` as an argument, appending the value `4` to the object referenced by both `a` and `b` , mutating the object.

On line 4, the `inspect`method is invoked on the object referenced by `a` returning the value `[1, 2, 3, 4]` that gets passed as an argument to the `puts` method invocation, outputting the value to the console.

This code snippet demonstrates variables as pointers and object mutability.


## Question #15

What is the output of this code? why?

```ruby
def modify_array(arr)
  arr.pop
end

numbers = [1, 2, 3, 4, 5]
modify_array(numbers)
puts numbers.inspect
```

**Answer**

This code outputs `[1, 2, 3, 4]`.

On line 5, local variable `numbers` is initialized and references an array object with value `[1, 2, 3, 4, 5]`.

On line 6, the method `modify_aray` is invoked and gets passed the value referenced by local variable `numbers` as an argument.

On lines 1-3, the method `modify_array`is defined and the method parameter `arr` is bound to the value referenced by local variable `numbers`. Within the method's body, the `pop` method is invoked on the object referenced by method local variable `arr`, removing and returning the last element of the array, in this case `5`.

On line 7, the `inspect` method is invoked on the object referenced by `numbers` and its return value `[1, 2, 3, 4]` gets passed to the `puts` method invocation as an argument, outputting it to the console.

## Question #16

What is the output of this code? why?

```ruby
x = "hello"
y = x
x.upcase!
puts y
```


## Question #17

What is the output of this code? why?

```ruby
def change_string(str)
  str.replace("new string")
end

original = "old string"
change_string(original)
puts original
```


## Question #18

What is the output of this code? why?

```ruby
a = [1, 2, 3]
b = a
a = [4, 5, 6]
puts b.inspect
```


## Question #19

What is the output of this code? why?

```ruby
def add_to_array(arr)
  arr = arr + [4]
end

original = [1, 2, 3]
add_to_array(original)
puts original.inspect
```


These code snippets cover various aspects of variables as pointers, including:•   Mutation of objects  
•   Method arguments and their effects on original objects  
•   Reassignment vs. mutation  
•   The behavior of different Ruby methods with respect to object referencesEach snippet can be used as a question to test understanding of how Ruby handles object references and variable assignment.
