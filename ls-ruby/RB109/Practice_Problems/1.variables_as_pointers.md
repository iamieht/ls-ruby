# Object Passing/Variables as Pointers

## Question # 1

Explain the concept of "Variables as Pointers". As part of your explanation, include a code snippet that accurately demonstrates this concept, and explain the effect it has within that example.

**Answer**

Variables don't contain values, they contain pointers to a physical space in memory, that store values. Variables are not deeply linked to each other.

```ruby
name = "Ivan"
my_name = name
name = "María"

puts name
puts my_name
```

On line 1, we initialized the variable `name` to reference the string object with value `"Ivan"`. On line 2, we initialized the variable `my_name` to reference the same object as variable `name`. On line 3, we reassign the variable `name` to the string object `"María"`.

On line 5, the `puts` method is invoked and gets passed the object referenced by variable `name` as an argument. As variable `name` references the string object with value `"María"`, this is output into the console. 

On line 6, the `puts` method is invoked and gets passed the object referenced by variable `my_name` as an argument, outputting the value `"Ivan"` to the console.

This code snippet demonstrates the concept of variables as pointers.


## Question # 2

What is the output of this code? Why? 

```ruby
a = "hi there"
b = a
a = "not here"

puts a
puts b
```

**Answer**

On line 1, the variable `a` is initialized and references the string object with value `"hi there"`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, `a` is reassigned and references the string object with value `"not here"`.

On line 5, the `puts` method is invoked and gets passed the value `"not here"`referenced by the variable `a`, outputting it to the console.

On line 6, the `puts` method is invoked and gets passed the value `"hi there"` referenced by the variable `b`, outputting it to the console.

This code snippet demonstrates the concept of variables as pointers and how variables are not deeply linked to each other.

## Question # 3

What is the output of this code? Why? 

```ruby
a = "hi there"
b = a
a << ", Bob"

puts a
puts b
```

**Answer**

On line 1, the variable `a` is initialized and references the string object with value `"hi there"`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, the method `#<<` is invoked on string object `"hi there"`, passing the string object with value `", Bob"` as an argument. This is a mutating method, so the object referenced by variable `a` is modified with the value `"hi there, Bob"`.

On line 5, the `puts` method is invoked and gets passed the string object with value `"hi there, Bob"` referenced by variable `a`, outputting it to the console.

On line 6, the `puts` method is invoked and gets passed the string object with the same value `"hi there, Bob"` which is also referenced by the variable `b`.

This concept demonstrates variables as pointers and mutation.

## Question # 4

What is the output of this code? Why? 

```ruby
a = [1, 2, 3, 3]
b = a
c = a.uniq

puts a
puts b
```

On line 1, the variable `a` is initialized and references an Array object with value `[1, 2, 3, 3]`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, the variable `c` is initialized and references the return value of the `uniq` method invocation on the object referenced by variable `a`. The `uniq` method is a non-destructive method, so a new Array object with value `[1, 2, 3]` is returned and assigned to the variable `c`. This has no effect on the object referenced by variables `a` and `b`.

On line 5, the `puts` method is invoked and gets passed the object referenced by `a`, outputting the value `1, 2, 3, 4` to the console.

On line 6, the `puts` method is invoked and gets passed the value referenced by `b` as an argument, outputting `1, 2, 3, 3` to the console, a both `a` and `b` are referencing the same object in memory.

This code demonstrates variables as pointers and how variables are not deeply linked to each other.


## Question # 5

Are `a` and `b` referencing the same object? Why? What is `a`? What if we called `map!` instead of `map`?

```ruby
def test(b)
  b.map { |letter| "I like the letter: #{letter}" }
end

a = ['a', 'b', 'c']
test(a)
```

Yes, `a` and `b` are referencing the same object.

On line 4, local variable `a` is initialized and references the Array Object with value `['a', 'b', 'c']`.

On line 5, the `test` method is invoked and gets passed the object referenced by local variable `a` , which is then bound to the parameter `b` of the `test` method. At this point both local variable `a` and method local variable `b` are referencing the same object in memory.

From lines 1-3, the `test` method is defined with a single parameter `b`. Within the method's body, the `map` method is invoked on the object referenced by the method local variable `b`and gets passed a block as an argument. Within the block, the parameter `letter` is assigned to each element of the array object and the string object with value `"I like the letter: #{letter}"`is returned, interpolating the value of the variable `letter` within the string object. A new array object is returned my the `map` method invocation, as it is not a destructive method, so after each iteration, a new array with the values `["I like the letter: a", "I like the letter: b", "I like the letter: c"]`is returned by the method as is the last line evaluated.

As the returned value from the method is not stored anywhere, the value is lost, so `a` still references the same Array object  with value `["a", "b", "c"]`.

This code snippet demonstrates the concept of object passing, in which Ruby behaves as "pass-by-value" as the original object is not mutated.

In case we called the method `map!` the original object will be mutated and now the variable `a` will reference the value `["I like the letter: a", "I like the letter: b", "I like the letter: c"]`. In this case the object passing strategy behaves like "pass-by-reference" as the original object is mutated.

## Question # 6

What is the output of this code? why?

```ruby
a = 5.2
b = 7.3
a = b
b += 1.1

puts a
puts b
```

**Answer**

This code outputs `7.3` and `8.4`

On line 1, the variable `a` is initialized and references the Integer Object with value `5.2`. On line 2, the variable `b` is initialized and references the value `7.3`. On line 3, the variable `a` is reassigned to the same value referenced by  `b`. On line 4, the method `#+` is invoked on the object referenced by `b` and gets passed `1.1` as an argument. The return value `8.4` is then reassigned to the variable `b`. As we are working with immutable objects, the return values of any method invocation will result in a new object being created.

On line 6, the `puts` method is invoked and gets passed the value referenced by `a` as an argument, outputting `7.3` to the console.

On line 7, the `puts`method is invoked and gets passed the value referenced by `b` as an argument, outputting `8.4`to the console.

This code snippet demonstrates the concept of variables as pointers and how variables are not deeply linked to each other.

## Question # 7

What is the output of this code? why?

```ruby
def test(str)
  str  += '!'
  str.downcase!
end

test_str = 'Written Assessment'
test(test_str)

puts test_str
```

**Answer**

The output is `Written Assessment`.

On line 6, the local variable `test_str` is initialized and references the string object with value `Written Assessment`.

On line 7, the `test` method is invoked and gets passed the value referenced by `test_str` as an argument. The value is then bound to the method parameter `str`.

Within the method's body, the method `#+` is invoked on the value referenced by method local variable `str` and gets passed the string object with value `!` as an argument. A new string object is created with the value `Written Assessment!` as return value of the method invocation, reassigning it to the variable `str`. On line 3, the method `downcase!` is invoked on the value referenced by method local variable `str` mutating the caller, which new value is now `written assessment!`. As this is the last evaluated expression in the method, there is an implicit return call.

As the return value of the `test` method invocation is not stored anywhere, the value is lost.

On line 9, the `puts` method is invoked and gets passed the value referenced by `test_str` as an argument, which references the string object with value `"Written Assessment"` , which is then output into the console.

This code snippet demonstrates object passing strategy and here Ruby behaves as "Pass-by-value", as the object passed into the method is not mutated, so the original object remains unchanged.



## Question # 8

What is the output of this code? why?

```ruby
def plus(x, y)
  x = x + y
end

a = 3
b = plus(a, 2)

puts a
puts b
```

**Answer**

The output is `3` and `5`.

On line 5, the local variable `a` is initialized and references the integer object with value `3`.

On line 6, the local variable `b` is initialized to the return value of the `plus` method invocation. `plus` is invoked and gets passed the value `3` referenced by local variable `a` and the integer object `2` as an argument.

From lines 1-3, the method `plus` is defined and the parameters `x` and `y` are bound to the object with values `3`and `2` respectively. 

Within the method's body, the expression `x + y` is evaluated to the value `5` and reassigned to the method local variable `x`, which is then implicitly returned by the method, as it is the last line evaluated.

The value `5` is assigned to the local variable `b` on line 6.

On line 8, the `puts` method is invoked and gets passed the value referenced by local variable `a`, outputting `3` to the console.

On line 9, the `puts` method is invoked and gets passed the value referenced by local variable `b`, outputting `5` to the console.

This code snippet demonstrates object passing, and as the objects passed into the method as immutable, the object passing strategy behaves as "pass-by-value".


## Question # 9

What do you think the output of this code will be when we call `puts y` at the end? And can you explain why?

```ruby
def increment(x)
  x << 'b'
end

y = 'a'

increment(y)
puts y
```

This question relates to concepts covered in the RB101 course, specifically dealing with object mutability, method side effects, and how Ruby handles string objects when passed to methods.
## Question # 10

Does this reassignment `name = 'bob'` change the object outside the method?

```ruby
def change_name(name) 
   name = 'bob'      
end

name = 'jim'
change_name(name)

puts name
```

## Question # 11

Does `str.capitalize!` affect the object outside the method?

```ruby
def cap(str) 
    str.capitalize!   # 
end

name = "jim"
cap(name)
puts name
```

## Question # 12

What is the output of this code? why?

```ruby
a = [1, 3]
b = [2]
arr = [a, b]
arra[1] = 5

p arr
```

## Question # 13

What will be the values of `arr1` and `arr2` after this code is executed? Can you explain why?

```ruby
arr1 = ["a", "b", "c"]
arr2 = arr1.dup

arr2.map! do |char| 
    char.upcase
end

puts arr1
puts arr2
```

This question relates to concepts covered in the RB101 course, specifically dealing with object duplication, mutability of arrays and strings, and the behavior of the `map!` method in Ruby.


## Question #14

What is the output of this code? why?

```ruby
a = [1, 2, 3]
b = a
b << 4
puts a.inspect
```


## Question #15

What is the output of this code? why?

```ruby
def modify_array(arr)
  arr.pop
end

numbers = [1, 2, 3, 4, 5]
modify_array(numbers)
puts numbers.inspect
```


## Question #16

What is the output of this code? why?

```ruby
x = "hello"
y = x
x.upcase!
puts y
```


## Question #17

What is the output of this code? why?

```ruby
def change_string(str)
  str.replace("new string")
end

original = "old string"
change_string(original)
puts original
```


## Question #18

What is the output of this code? why?

```ruby
a = [1, 2, 3]
b = a
a = [4, 5, 6]
puts b.inspect
```


## Question #19

What is the output of this code? why?

```ruby
def add_to_array(arr)
  arr = arr + [4]
end

original = [1, 2, 3]
add_to_array(original)
puts original.inspect
```


These code snippets cover various aspects of variables as pointers, including:•   Mutation of objects  
•   Method arguments and their effects on original objects  
•   Reassignment vs. mutation  
•   The behavior of different Ruby methods with respect to object referencesEach snippet can be used as a question to test understanding of how Ruby handles object references and variable assignment.
