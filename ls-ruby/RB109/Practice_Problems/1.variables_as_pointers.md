# Object Passing/Variables as Pointers

## Question # 1

Explain the concept of "Variables as Pointers". As part of your explanation, include a code snippet that accurately demonstrates this concept, and explain the effect it has within that example.

**Answer**

Variables don't contain values, they contain pointers to a physical space in memory, that store values. Variables are not deeply linked to each other.

```ruby
name = "Ivan"
my_name = name
name = "María"

puts name
puts my_name
```

On line 1, we initialized the variable `name` to reference the string object with value `"Ivan"`. On line 2, we initialized the variable `my_name` to reference the same object as variable `name`. On line 3, we reassign the variable `name` to the string object `"María"`.

On line 5, the `puts` method is invoked and gets passed the object referenced by variable `name` as an argument. As variable `name` references the string object with value `"María"`, this is output into the console. 

On line 6, the `puts` method is invoked and gets passed the object referenced by variable `my_name` as an argument, outputting the value `"Ivan"` to the console.

This code snippet demonstrates the concept of variables as pointers.


## Question # 2

What is the output of this code? Why? 

```ruby
a = "hi there"
b = a
a = "not here"

puts a
puts b
```

**Answer**

On line 1, the variable `a` is initialized and references the string object with value `"hi there"`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, `a` is reassigned and references the string object with value `"not here"`.

On line 5, the `puts` method is invoked and gets passed the value `"not here"`referenced by the variable `a`, outputting it to the console.

On line 6, the `puts` method is invoked and gets passed the value `"hi there"` referenced by the variable `b`, outputting it to the console.

This code snippet demonstrates the concept of variables as pointers and how variables are not deeply linked to each other.

## Question # 3

What is the output of this code? Why? 

```ruby
a = "hi there"
b = a
a << ", Bob"

puts a
puts b
```

**Answer**

On line 1, the variable `a` is initialized and references the string object with value `"hi there"`. On line 2, the variable `b` is initialized and references the same object as `a`. On line 3, the method `#<<` is invoked on string object `"hi there"`, passing the string object with value `", Bob"` as an argument. This is a mutating method, so the object referenced by variable `a` is modified with the value `"hi there, Bob"`.

On line 5, the `puts` method is invoked and gets passed the string object with value `"hi there, Bob"` referenced by variable `a`, outputting it to the console.

On line 6, the `puts` method is invoked and gets passed the string object with the same value `"hi there, Bob"` which is also referenced by the variable `b`.

This concept demonstrates variables as pointers and mutation.

## Question # 4

What is the output of this code? Why? 

```ruby
a = [1, 2, 3, 3]
b = a
c = a.uniq

puts a
puts b
```

## Question # 5

Are `a` and `b` referencing the same object? Why? What is `a`? What if we called `map!` instead of `map`?

```ruby
def test(b)
  b.map { |letter| "I like the letter: #{letter}" }
end

a = ['a', 'b', 'c']
test(a)
```

## Question # 6

What is the output of this code? why?

```ruby
a = 5.2
b = 7.3
a = b
b += 1.1

puts a
puts b
```

## Question # 7

What is the output of this code? why?

```ruby
def test(str)
  str  += '!'
  str.downcase!
end

test_str = 'Written Assessment'
test(test_str)

puts test_str
```

## Question # 8

What is the output of this code? why?

```ruby
def plus(x, y)
  x = x + y
end

a = 3
b = plus(a, 2)

puts a
puts b
```

## Question # 9

What do you think the output of this code will be when we call `puts y` at the end? And can you explain why?

```ruby
def increment(x)
  x << 'b'
end

y = 'a'

increment(y)
puts y
```

This question relates to concepts covered in the RB101 course, specifically dealing with object mutability, method side effects, and how Ruby handles string objects when passed to methods.
## Question # 10

Does this reassignment `name = 'bob'` change the object outside the method?

```ruby
def change_name(name) 
   name = 'bob'      
end

name = 'jim'
change_name(name)

puts name
```

## Question # 11

Does `str.capitalize!` affect the object outside the method?

```ruby
def cap(str) 
    str.capitalize!   # 
end

name = "jim"
cap(name)
puts name
```

## Question # 12

What is the output of this code? why?

```ruby
a = [1, 3]
b = [2]
arr = [a, b]
arra[1] = 5

p arr
```

## Question # 13

What will be the values of `arr1` and `arr2` after this code is executed? Can you explain why?

```ruby
arr1 = ["a", "b", "c"]
arr2 = arr1.dup

arr2.map! do |char| 
    char.upcase
end

puts arr1
puts arr2
```

This question relates to concepts covered in the RB101 course, specifically dealing with object duplication, mutability of arrays and strings, and the behavior of the `map!` method in Ruby.


## Question #14

What is the output of this code? why?

```ruby
a = [1, 2, 3]
b = a
b << 4
puts a.inspect
```


## Question #15

What is the output of this code? why?

```ruby
def modify_array(arr)
  arr.pop
end

numbers = [1, 2, 3, 4, 5]
modify_array(numbers)
puts numbers.inspect
```


## Question #16

What is the output of this code? why?

```ruby
x = "hello"
y = x
x.upcase!
puts y
```


## Question #17

What is the output of this code? why?

```ruby
def change_string(str)
  str.replace("new string")
end

original = "old string"
change_string(original)
puts original
```


## Question #18

What is the output of this code? why?

```ruby
a = [1, 2, 3]
b = a
a = [4, 5, 6]
puts b.inspect
```


## Question #19

What is the output of this code? why?

```ruby
def add_to_array(arr)
  arr = arr + [4]
end

original = [1, 2, 3]
add_to_array(original)
puts original.inspect
```


These code snippets cover various aspects of variables as pointers, including:•   Mutation of objects  
•   Method arguments and their effects on original objects  
•   Reassignment vs. mutation  
•   The behavior of different Ruby methods with respect to object referencesEach snippet can be used as a question to test understanding of how Ruby handles object references and variable assignment.
