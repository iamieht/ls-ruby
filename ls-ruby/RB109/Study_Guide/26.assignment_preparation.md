# Assignment Preparation

## Precision of Language

* Say **method definition** or **method invocation / method call**
* Talk about **output, return value and mutations**
* A value is assigned to a variable
* Use **evaluates as true** or **is truthy** when discussing expressions that evaluate to `true` in a Boolean context
* Use **is true** or **is equal to true** only when talking about Boolean `true`
* Be concise
* Divide your answers in paragraphs
* Say `a` is initialized and the value `hello` is assigned to it
* Distinguish between method parameters and arguments: a method is defined with parameters but it is called with arguments.

## Vocabulary to keep in mind

```ruby
def foo(string)
	...
end
```

*We are defining a method called `foo` which takes 1 parameter named `string`*

```ruby
foo("hello")
```

*We are calling the method `foo` and pass the `String` `"hello"` as argument.*

```ruby
var = "hello"
```

*We are initializing a local variable `var` to the String `"hello"`*

```ruby
puts "hello"
```

*We are calling the `puts` method and pass it the `String` `"hello"` as an argument. This invocation will output `"hello"` and return `nil`*

```ruby
i = 10

loop do
	i -= 1
	break if i == 0
end
```

*We are initializing a local variable `i` to the `Integer` `10`.*
*We are calling the method `loop` and pass it a `do..end` block as an argument.*
*Inside the block, we are reassigning the local variable `i` to the return value of the `Integer#-` method called on the local variable `i` passed to it as an argument.*
*We break out of the loop with the keyword `break` if the value of the object that local variable `i` is referencing is equal to `0`.*

## [Speaking in Ruby]([Speaking in Ruby. Grammar tips for reading Ruby aloud —… | by Rebecca Biancofiore | Medium](https://medium.com/@rebeccabiancofiorecw/speaking-in-ruby-caabc4f1adf6))

### Key Passive Verbs

Below are the main verbs you need to concisely read Ruby code in English. It’s important to note — using these only becomes easy when you learn to read **right to left.** In the examples listed below, these verbs are **bolded** for emphasis.

- **is invoked / is called**
- **is initialized**
- **is reassigned**
- **is passed**
- **is returned**
- **is mutated**
- **is referenced**
- **is evaluated**
- **is chained**
- **is bound**

### Helpful Active Verbs

- _passes_ — a method _passes_ an element into a block
- _returns_ — a block _returns_ a value to a method
- _mutates_ — a method _mutates_ the calling object
- _references_ — a variable _references_ an object
- _binds_ — an object _binds_ to a parameter

Most of the time, passive voice works equally well:

- an element **is passed** into a block
- a value **is returned** by a block
- a calling object **is mutated** by a method
- an object **is referenced** by a variable
- an object **is bound** to a parameter

### Examples

#### Example 1 

```ruby
"earlobe.chars"
array_of_letters_in_the_word_earlobe = "earlobe".chars
```

**Passive voice:** 
The `#chars` method **is called on** a string object with value `"earlobe"`.
Local variable `array_of_letters_in_the_word_earlobe` **is initialized** to reference the return value of the `#chars` method call.

Right to left reading using passive verbs makes it simple to explain even complex nested iterative structures containing multiple method calls and return values.

**Active voice:** We are calling the `#chars` method on the string object `"earlobe"`. We initialized the variable `array_of_letters_in_the_word_earlobe` with the reference of the return value of calling the method `#chars` on the string object `"earlobe"`.

#### Example 2

```ruby:n
def question(string)
	string += '?'
	string.downcase!
end

example_string = 'Today is Monday'

question(example_string)

puts example_string
```

On Line 6 local variable `example_string` **is initialized** to reference a string with value `Today is Monday`. 

On Line 8 the `question` method **is invoked** and the string object **referenced** by `example_string` **is passed** in as an argument. The `question` method **is defined** on lines 1-4. The string object **passed** in as an argument **is bound** to method parameter `string`.

On Line 1, the `#+` method **is called** on the string **referenced** by method local variable `string`. This method call **is passed** string object `?` as an argument, `#+` is a non-destructive method -- when it's called, it created and modifies a copy of the string it's called on.

Here, the method call concatenates `?` to the end of the string object **referenced** by `string` and *returns* the new string object `"Today is Monday?"`.  (Active verbs italicized -- here the method is actually doing something.) The method local variable `string` **is reassigned** to reference this new string object. 

(Notice this description on line 2 is starting in the middle, focused on what is happening with the `#+` method. The method is doing something, so that’s our starting point. Once that action on the right is complete, we then move left and describe the reassignment. Explaining the method call before the reassignment helps you avoid getting stuck when trying to describe what the reassignment is referencing.)

On line 3, the mutating `#downcase!` method **is called** on the object **referenced** by `string`. This method *converts* all letters in a string to their lowercase version. Since this method call is the last evaluated expression in the method, the method's return value is `today is monday?`.

The method's return value is a different string object than the object initially **passed** into the method as an argument. The non-mutating method call on line 2 *creates* a copy of the original string. Everything else that happens in the method happens to that copy, not the original string.

On line 10 the `#puts` method **is invoked** and **passed** the object **referenced** by local variable `example_string`. This line *outputs* the original string object, with no mutations - `"Today is Monday"`.

This code demonstrates the concept of pass by value. When the argument is initially **passed** into the method, both `example_string` and `string` reference the same string object. However, on line 2 in the method's body a copy **is created**, and the code within the method only affects the copy, not the original object.

#### Example 4

```ruby
selected_foods = [['apple', 'kiwi'], ['artichoke', 'broccoli']].select do |arr|
					arr.select do |food|
						food.start_with?('a')
					end
				end
p selected_foods
```

On line 1 the `#select` method **is called** on a nested array. A `do..end` block **is passed** as an argument to the `#select` method call. On each iteration, a subarray **is passed** into the block and **is bound** to block parameter `arr`.

On line 2, the `#select` method **is called** on the subarray **referenced** by block local variable `arr`. The inner `#select` **is passed** a `do..end` block as an argument. On each iteration, one subarray **is passed** into the block and **is bound** to block parameter `food`.

On line 3, the `#start_with?` method **is invoked** on the string object **referenced** by block local variable `food`, and **passed** string object `a` as an argument. On each iteration, this method call *evaluates* the calling object and *returns* a Boolean: `true` if the string begins with `a`, `false` if it doesn't.

`#select` *works* by selecting those objects for which the block iteration *returns* a truthy value and returning them in a new array. (in this case, the inner `#select` will return `['apple']` and ignore `['kiwi']`, which returns `false`. On the second iteration, it will again return `['artichoke']` and ignore `['broccoli']`).

The arrays **returned** by the inner `#select` become the block return values for the outer `#select`. Since each of these returned new arrays has a truthy value, each iteration of the outer `#select` block will return `true`. The entire subarray **is selected** and **returned** in a new nested array. On line 1 local variable `selected_foods` **is initialized** to reference the return values of this nested iteration.

On line 7 the `#p` method **is invoked** and **passed** the nested array **referenced** by `selected_foods` as an argument. This method call both outputs and returns a copy of the original nested array. 

The code demonstrates the importance of understanding ow block return values are used to perform selection on collection objects.

### Tips

* Don’t repeat yourself. If you’re describing a block or an iterative structure (like each, select, map, or times), take a bird’s eye view. You’ll waste time and run in circles if you find yourself trying to describe each iteration. Instead step back and verbalize what the iterative structure as a whole is doing.
* Consider whether you’re describing actions being performed by the interpreter (and use passive voice) or by some part of the code (and use active voice). A good rule of thumb: if you can identify who’s responsible for the action, active voice works. If not, default to passive. (What reassigns a variable? Interpreter. Passive. What passes a return value back to a method? A block. Active works.)
* Focus on one method call at a time.
* Try to keep sentences short — one method call, assignment, etc., per sentence helps writing stay clear.
* Use terminology to demonstrate your knowledge, but don’t let it trap you. Saying, “The string object with value `'hello'` referenced by block local variable `string` ..." the first time you encounter the object demonstrates you know how to describe that object. Feeling compelled to use that phrase every single time you refer back to it will make your writing lengthy, time-consuming to write, and harder to read. Once you've demonstrated your knowledge, calling it `'hello'` is fine as long as the context is clear.
* Methods are king. Methods are doing all the heavy lifting, and the method should take precedence in descriptions. A method **is called on** a variable, and **is passed** an argument. As much as possible, orient sentences around describing what the method calls are doing — assignment, reassignment, and argument passing are often happening in response to the method call.
* Integrate descriptions as you go. If you look back at Example 3 above, you can see how explanation is woven is:

	* On line 1 the `#select` method is called on a nested array. A `do...end` block is passed as an argument to the `#select` method call. **On each iteration, a subarray is passed into the the block and is bound to block parameter** `**arr**` **.** On line 2, the `#select` method is called on the subarray **referenced** by block local variable `arr`...

	* Of these four sentences, three are reading the code. The bolded sentence is explanation dropped in at a convenient breaking point, before starting on the next section of code. Explanation can be incorporated like this, but if it’s easier you can also hold off and instead describe at the end.

	* Opting for the incorporated method helps keeps thoughts organized and leads to a shorter description, but it might take a little extra work at first to jump back and forth between reading code and explaining code.
## Method definition vs. method invocation

A **method definition** is the place where we write out out method and what we want it to do.

```ruby:n
def my_example_method
	put "this is a cool method!"
end
```

A **method invocation or method call** is the place where we actually make use of this method.

```ruby
my_example_method # => "this is a cool method!" 
```

## Truthiness

* Be clear about the distinction between *truthy* values and the Boolean `true` and *falsy* values and the Boolean `false`.
* Every value apart from `false` and `nil` evaluates to `true` in a Boolean context.
* This is not the same as saying that *truthy* values equal to the Boolean value `true` and *falsy* values are equal to the Boolean `false`.

## Return values of method invocations and blocks

Ruby methods always return the evaluated result of the last expression in both blocks and method definitions unless and explicit return comes before it.

## Local variable scope

There are two major areas where we encounter local variable scoping rules:

* Method invocations with blocks (`do..end` or `{}`)
* Method definitions

### Local variable scope in method invocations with blocks

* **Blocks are actually arguments passed to method invocations**. We define blocks by passing them to a method invocation.
* Technically any method can be called with a block, but the block is only executed if the method is defined in a particular way.

**Method definition not using a a passed block**

```ruby
def greetings
	puts "Goodbye"
end

word = "Hello"

greetings do
	puts word
end

# Outputs 'Goodbye'
```

**Method definition using the passed block**

```ruby
def greetings
	yield
	puts "Goodbye"
end

word = "Hello"

greetings do
	puts word
end

# Outputs 'Hello'
# Outputs 'Goodbye'
```

Blocks also **create a new scope for local variables**. When we pass a block to a method invocation, we get the following:
	* An **inner scope** created inside of the block
	* An **outer scope** existing around and outside of the block

**A variable's scope is determined by where it is initialized**

When it comes to the combination of inner and outer scope, there are certain rules that come into play.

### Outer scope variables can be accessed by inner scope

```ruby
a = 1 # outer scope variable

loop do # the block following the invocation of the `loop` method creates an inner scope
	puts a # => 1
	a = a + 1 # "a" is re-assigned to a new value
	break # necessary to prevent infinite loop
end

puts a # => 2 "a" was re-assigned in the inner scope
```

### Inner scope variables cannot be accessed in outer scope

```ruby
loop do # the block following the invocation of the `loop` method creates an inner scope
	b = 1
	break
end

puts b # => NameError: undefined local variable or method `b' for main:Object
```

### Peer scopes do not conflict

```ruby
2.times do
	a = 'hi'
	puts a # 'hi' <= this will be printed out twice due to the loop
end

loop do
	puts a # => NameError: undefined local variable or method `a' for main:Object
	break
end

puts a # => NameError: undefined local variable or method `a' for main:Object
```

## Variable shadowing

Is a Ruby mechanism that comes into play when we have a block that is passed to a method invocation with a parameter that has the same name as a local variable in the outer scope.

```ruby
number = 10

[1, 2, 3].each do |number|
	number = 2
end
```

What variable shadowing does, is preventing access to the outer scope variable.

This is not something that you want to have happen, so use different variable names.

## Variables in method definitions

A block might have a leaky scope (being able to access and change the outer scope) but a **method's scope is entirely self-contained and separate**. The only way that a method definition can access **LOCAL** variables is by passing them as arguments or by initializing them inside its definition. There is not notion of outer/inner scope,

## Pass by Value vs. Pass by Reference

There are two ways to handle objects that get passed to methods:

* Pass by Value
* Pass by Reference

### Pass by Value

Means that we provide the method with a copy of the object we pass to it. Whatever we do with that object inside of the method does not reflect on the outside object since we are altering its copy, not the object itself.

An example of a language that is purely pass by value would be C.

In some ways Ruby also shows "pass-by-value" behavior:

```ruby
def change_name(name)
	name = 'bob' # This reassignment does not change the object outside the method
end

name = 'jim'
change_name(name)
puts name # => jim
```

### Pass by Reference

Means that the method gets passed a reference to the original object, not a copy as is the case with pass by value. This also implies that everything we do with the object inside of the method directly alters the outside object as well.

In some ways Ruby also shows "pass by reference" behavior:

```ruby
def cap(str)
	str.capitalize!
end

name = "jim"
cap(name)
puts name # => Jim
```

### Call by sharing / Pass by value of the reference

Ruby exhibits behavior of both pass by value and pass by reference. Some people call this "call by sharing" or "pass by value of the reference". The ground rule that Ruby maintains is **when an operations within the method mutates the caller, it will affect the original object**.

## Variables as pointers

### What are variables?

Variables in Ruby as basically references to objects in memory. These objects hold some sort of state or value and associated behavior.

```ruby
number = 42
# We tell Ruby to associate the variable number with the Integer object whose value is 42.

number.even?
# This also means that we can use this variable to make use of any behavior defined in the object's class.
```

### Object Id

Every object in Ruby has a unique object id. This unique id can be easily retrieved by calling the `#object_id` method on any object.

```ruby
number = 18
number.object_id

true.object_id
5.object_id
nil.object_id
"abc".object_id
```

### Referencing

Since a variable is a reference to an object in memory, this also allow us to have different variables referencing the same exact object.

```ruby
blade = "runner"
bar = blade

blade.object_id
# 34
bar.object_id
# 34
```

### Reassignment

When two variables point to the same object, we can still make one variable point to another object entirely.

```ruby
blade = "runner"
bar = blade

blade = "vampire"
blade.object_id
# 78

bar.object_id
# 34
```

### Mutability

We can also decide to mutate an object instead, which means changing its value in a certain way. Not all objects in Ruby allows this to happen. Some objects are immutable, the most prevalent bein integers, Booleans, ranges and nil. They are immutable because their classes do not provide any associated behavior that let us change their values.

```ruby
meaning_of_life = 42
meaning_of_life.object_id
# 22

meaning_of_life = meaning_of_life * 2
meaning_of_life.object_id
# 89
```

Even though it looks like we mutated the `meaning_of_life` variable, we actually simply
reassigned it, which as we saw above, does not change the object but simply points the
variable to a new object.

That being said, most of the objects in Ruby are mutable, meaning the class of those
objects permits modification of the object's state in some way. Some examples here are
strings, arrays, hashes, ...

```ruby
arr = ["a", "b", "c"]
arr.object_id
# 19

arr[0].object_id
# 75

arr[0] = "A"
arr[0].object_id
# 99

arr.object_id
# 19
```

As we stated above, everything in Ruby has an object_id, so while the array arr clearly
has an object_id, its different elements do too. We can then use a setter method to
reassign one of those elements of `arr` to a different value, hereby mutating `arr` but not
its elements.

```ruby
arr = ["a", "b", "c"]
arr.object_id
# 19

arr[0].object_id
# 75

arr[0].upcase!
arr[0].object_id
# 75

arr.object_id
# 19
```

Here we go one step further. Since the first element in the `arr` array is a string, which is
mutable, we can change its value in place, without reassigning it. This means that we
are now mutating `arr[0]` but also `arr` itself.

### Indexed assignment is mutating

It is important to realize here that while assignment and reassignment are non-mutating,
indexed assignment like you would see with strings, arrays, hashes is in fact mutating.
**This is because indexed assignment is actually syntactic sugar for a method defined
on the calling object's class.**

```ruby
string = "abc"
string.object_id
# 34

string[1] = "x"

string
# axc

string.object_id
# 34
```

### Concatenation is mutating

Just as indexed assignment is behavior a class provides for its object, so is
concatenation. And just like indexed assignment, it is mutating. This way of adding
elements to collections is used by collections like arrays, hashes and strings (collection
of chars).

```ruby
blade = "runner"
blade.object_id
# 22

blade << " 2049"

blade
# runner 2049
blade.object_id
# 22
```

### Setters are mutating

Somewhat similar to indexed assignment, setters are also methods that are used to
modify the state of an object. Both look like assignment on a superficial level.

```ruby
person = { name: "Rein" }
person.object_id
# 89

person.name = "Van Imschoot"
person.object_id
# 89
```

This looks like assignment but it is actually a setter called on the object person ,
modifying its state.

## Working with collections

### `#each`

```ruby
[1, 2, 3].each do |num|
	puts num
end

{ "a" => 100, "b" => 200 }.each do |key, value|
	puts key
	puts value
end
```

The `each` method calls the given block once for each element in the collection it is
called on, passing that element as a parameter. Afterwards, it returns the collection
itself.

### `#select`

```ruby
[1, 2, 3].select do |num|
	num.odd?
end
# returns [1, 3]

{ "a" => 100, "b" => 200, "c" => 300 }.select do |key, value|
	v < 200
end
# returns { "a" => 100}
```

The `select` method calls the given block once for each element in the collection it is
called on and **evaluates the return value of the passed block**. When evaluating said
return value, select only cares about its truthiness.

If the return value of the block is "truthy", then the element during that iteration will be
selected. If the return value of the block is "falsy" then the element will not be selected.

`select` then returns a new collection containing all of the selected elements.

### `#map`

```ruby
[1, 2, 3].map do |num|
	num * 2
end
# returns [2, 4, 6]

[1, 2, 3].map do |num|
	puts num # puts returns nil
end
# returns [nil, nil, nil]
```

The `map` method calls the given block once per each element in the collections it is called on and **evaluates the return value of the passed block.** It then uses the return value to build a new collection of transformed values. `map` always return a collection of the same length of the collection it is called upon.

## Sorting of arrays

The sorting of any kind of collection requires the usage of a complex algorithm, which
isn't important for our purposes right now. What is important to know is that
comparison lies at the heart of sorting.
When we sort an array we essentially compare the different values which each other by
a specific criterion. This criterion can be provided by us, the programmers, or by Ruby
itself.

### The `<=>` operator

Any type of object that we want to sort in a collection needs to implement a `<=>`
method.

The `<=>` method compares two values of the same type and returns -1 , 0 or 1 ,
depending on whether the first object is less than, equal to, or greater than the second
object. If the two objects cannot be compared then nil is returned.

```ruby
2 <=> 1 # => 1
1 <=> 2 # => -1
2 <=> 2 # => 0
'b' <=> 'a' # => 1
'a' <=> 'b' # => -1
'b' <=> 'b' # => 0
1 <=> 'a' # => nil
```

The return value of the `<=>` method is used by sort to determine the order in which to
place the items. If `<=>` returns `nil` to sort then it throws an argument error.

```ruby
['a', 1].sort # => ArgumentError: comparison of String with 1 failed
```

### Sorting order

If the type of object you want to sort implements a <=> operator, it is important to
know how it is actually implemented.

#### Integers

By default, `Integer` objects will be sorted in ascending order.

```ruby
[3,4,1,2,5].sort # => [1,2,3,4,5]
```

#### Strings

The `<=>` implementation of String objects uses the ASCII table to determine the sorting
order.
The ASCII table gives all characters a specific position. It's not required to learn them by
heart but it is helpful to know the following general rules:
* Uppercase letters come before lowercase letters
* Digits and (most) punctuation come before letters
* There is an extended ASCII table containing accented and other characters - this
comes after the main ASCII table

```ruby
["a", "A", "!"].sort # => ["!", "A", "a"]
```

When dealing with multi-character strings, the `String#<=>` method compares them
character by character. If two strings are equal but one is longer than the other, the
longer string will be considered greater.

```ruby
['arc', 'bat', 'cape', 'ants', 'cap'].sort
# => ["ants", "arc", "bat", "cap", "cape"]
```

### Subcollections

Arrays can also be compared and much like the `String#<=>`  method compares strings
character by character, the `Array#<=>` method compares them element by element.
If two elements are of different types, it will once again result in an `ArgumentError` .

### Calling `#sort` with a block

We can also call sort with a block. This gives us more control over how the items are
sorted. The block needs two arguments passed to it (the two items to be compared)
and the return value of the block has to be `-1` , `0`, `1` or `nil` .

```ruby
[2, 5, 3, 4, 1].sort do |a, b|
	a <=> b
end
# => [1, 2, 3, 4, 5]

[2, 5, 3, 4, 1].sort do |a, b|
	b <=> a
end
# => [5, 4, 3, 2, 1]
```