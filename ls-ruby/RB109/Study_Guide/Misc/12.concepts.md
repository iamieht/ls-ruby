# Concepts

## Variables as Pointers

Variables act as pointers which references objects in memory and are not deeply linked to each other. 

```ruby
num1 = 5
num2 = num1
num1 = 10

puts num1 # 10
puts num2 # 5
```
## Variable Shadowing

It happens when a block parameter has the same name as a local variable initialized in an outer scope, preventing access and modification to the outer scope variable from within the block.

```ruby
result = 0

2.times do |result|
  result += 1
end

puts result
```

## Local variable scope in relation to method definitions

Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. The only way to make the outer scope available to the method is via parameters.

```ruby
name = "Ivan"

def change_name(name)
	name = "Ivan the terrible"
end

puts change_name(name)
puts name
```


## Local variable scope in relation to blocks, nested blocks and peer blocks

Blocks are pieces of code that follows a method invocation and are delimited by  `do..end` or curly braces. They create an inner scope.
Inner scope can access and change variables initialized in an outer scope, but not vice versa. 
Nested blocks create nested scopes and obey the same outer/inner scope rules as variables.
Peer blocks do not conflict as they have their own scope and cannot reference variables initialized in another block.

```ruby
# local variable scope in relation to blocks
name = "Ivan"
1.times do |counter|
	name << " the terrible"
end
puts name # outputs Ivan the terrible
puts counter # NameError as counter cannot be referenced in the outer scope as it was initialized in an inner scope

# nested blocks
result = 0
2.times do |num|
	result += num
	puts nested_num # NameError as the outer scope cannot reference inner scope
	2.times do |nested_num|
		result += nested_num
		puts num
	end
end
puts result

# peer blocks
2.times do |num|
	puts num
end

2.times do |counter|
	puts num # NameError as num was initialized in another peer block
end
```

## Scope of constants

Constants have a lexical scope, meaning that they are available throughout the entire program, regardless of where they are defined.

```ruby
MY_CONSTANT = 100
# Rule 1: Constants can be access by methods
def output_constant 
  puts MY_CONSTANT
end

output_constant # 100

#Rule 2: Constants can be accessed by method invocation with a block
2.times do |counter|
	puts "Outputting #{MY_CONSTANT} #{counter + 1} time(s)"
end

# Rule 3: Constants initialized in an inner scope can be accessed in the outer scope
1.times do
	CONSTANT = "I am a constant"
end

puts CONSTANT

```
## Mutating values vs. reassigning variables

### Mutation: 

1. Modifies the existing object that the variable(s) points to.
2. Changes the object in place.
3. Keeps the same object ID.

```ruby
str = "I am the original String object"
puts "#{str} with object ID #{str.object_id}"
str.gsub!("original", "mutated")
puts "#{str} with object ID #{str.object_id}"
```

### Reassignment:

1. Creates a new object and points the variable to it.
2. Does not change the original object.
3. Non-mutating operation.

```ruby
str = "I am the original String object"
puts "#{str} with object ID #{str.object_id}"
str = "I am a new String object"
puts "#{str} with object ID #{str.object_id}"
```

## Method definition vs. method invocation

1. Method definition is when we define a method with the `def` keyword
2. Method invocation is when we call a method (and pass arguments to it)

```ruby
def message(message) # method definition
	puts message
end

message("Hola") # method invocation
```

## Passing and using blocks with methods

Any method can be called with a block, but the block is only executed if the method is defined in a particular way (`yield` keyword). The block act as an argument to the method invocation.

```ruby
# Block not executed

def greetings
  puts "Goodbye"
end

word = "Hello"

greetings do
  puts word
end

# Outputs 'Goodbye'

# Block executed
def greetings
  yield
  puts "Goodbye"
end

word = "Hello"

greetings do
  puts word
end

# Outputs 'Hello'
# Outputs 'Goodbye'
```

## Parameters vs. Arguments

**Parameters** are variables in a method definition or block that act as placeholders for values.

**Arguments** are the actual values passed to a method when it's called.

```ruby
def greet(name)
    puts "Hello, #{name}!"
end

greet("Ivan")
```


## Default parameters

Are default values assigned to the method parameters. If an argument isn't provided for a parameter with a default value, the default value will be used.

```ruby
def output_numbers(a, b = 2, c = 3)
    puts "#{a}, #{b}, #{c}"
end

output_numbers(1)
```


## Implicit vs. explicit return values

**Implicit return:**
	1. Ruby methods automatically return the value of the last executed expression.
	
```ruby
def add(a, b)
    a + b
end

puts add(3, 5)
```


**Explicit return:**
	1. Uses the `return` keyword to specify the return value.
	2. Can be used to return early from a method.
	3. The `return` keyword immediately exits the method, returning the specified value.
	4. Multiple values can be return by the return keyword (`return 1, 2, 3`)

```ruby
def check_positive(number)
    return false if number <= 0
    true
end
```


## Mutating vs. non-mutating methods

1. **Mutating methods:**
	1. Change the original object they're called on or passed to
	2. Often end with a bang (!) but not always
	3. Examples: `Array#push`, `Array#<<`, `String#upcase!`
2. **Non-mutating methods:**
	1. Return a new object, leaving the original unchanged
	2. Do not modify the object they're called on
	3. Examples: `String#upcase`, `Array#map`, `String#+`

1.  **"Mutates the caller"**: This means the method changes the object it's called on. For example, if you have an array and call a method that adds an element to it, the original array is modified.
2.  **"Mutates the arguments"**: This means the method changes the objects passed to it as arguments.
3. **"Change the value in that object's address space"**: This refers to modifying the actual object in memory, rather than creating a new object.

```ruby
def mutate(arr)
  arr.pop
end

def not_mutate(arr)
  arr.select { |i| i > 3 }
end

a = [1, 2, 3, 4, 5, 6]
mutate(a)
not_mutate(a)

puts a
```

## Using method return values as arguments to other methods

Every expression and method in Ruby returns a value, which can be used as an argument to another method invocation.

```ruby
# Using the return value of String#upcase as an argument to puts
puts "hello".upcase

# Using the return value of Array#join as an argument to puts
puts [1, 2, 3].join(", ")

# Using the return value of Integer#to_s as an argument to String#reverse
puts 12345.to_s.reverse

# Using the return value of one method as an argument to another method
def add_five(num)
  num + 5
end

def multiply_by_two(num)
  num * 2
end

result = multiply_by_two(add_five(10))
puts result  # Output: 30

# Chaining multiple methods
puts "hello world".split.map(&:capitalize).join(' ')
```
## Mutable vs. immutable data types

## Output vs. return

## Pass-by-reference vs. pass-by-value

Ruby always behaves as pass by value of the reference. That means that Ruby always passes a copy of the reference, which is not the object itself, but a reference to the object. So inside the method, whatever happens to that object, could mean one of two things: **either** Ruby behaves as if "pass-by-value" when the actions on that object won't mutate it (or if the object is immutable) **or** Ruby behaves as if "pass-by-reference" when the object is mutated.


## Truthiness



In RB101, a "concept" refers to a fundamental programming principle or idea that you're learning and applying. These are the building blocks of programming that you'll use to solve problems and write code. Some key concepts in RB101 include:1.  Variables and data types  
2.  Control flow (if/else statements, loops)  
3.  Methods and return values  
4.  Arrays and hashes  
5.  Iteration and blocks  
6.  Variable scope  
7.  Mutability and immutability  
8.  Truthiness  
9.  Object passing (pass by reference vs. pass by value)Understanding these concepts means being able to recognize them in code, explain how they work, and use them effectively in your own programming. As you progress through RB101, you'll encounter these concepts repeatedly, each time gaining a deeper understanding of how they function and how to apply them in different situations.

there are indeed sub-concepts within the key concepts in RB101. Here are some important ones:
1.  Variables and Data Types:  
    •   Local variables  
    •   Constants  
    •   Type conversion
    2.  Control Flow:  
    •   Ternary operators  
    •   Case statements
    3.  Methods:  
    •   Method definition and invocation  
    •   Default parameters  
    •   Explicit and implicit return
    4.  Arrays and Hashes:  
    •   Array and hash methods  
    •   Nested collections
    5.  Iteration and Blocks:  
    •   Each, map, select methods  
    •   Block parameters
    6.  Variable Scope:  
    •   Method scope  
    •   Block scope  
    •   Shadowing
    7.  Mutability:  
    •   Destructive vs. non-destructive methods
    8.  Truthiness:  
    •   Falsey values (false and nil)  
    •   Short-circuit evaluation
    9.  Object Passing:  
    •   Object ids  
    •   Variable reassignment vs. mutation