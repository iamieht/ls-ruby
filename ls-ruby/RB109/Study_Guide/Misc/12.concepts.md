# Concepts

## Variables as Pointers

Variables act as pointers which references objects in memory and are not deeply linked to each other. 

```ruby
num1 = 5
num2 = num1
num1 = 10

puts num1 # 10
puts num2 # 5
```
## Variable Shadowing

It happens when a block parameter has the same name as a local variable initialized in an outer scope, preventing access and modification to the outer scope variable from within the block.

```ruby
result = 0

2.times do |result|
  result += 1
end

puts result
```

## Local variable scope in relation to method definitions

Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. The only way to make the outer scope available to the method is via parameters.

```ruby
name = "Ivan"

def change_name(name)
	name = "Ivan the terrible"
end

puts change_name(name)
puts name
```


## Local variable scope in relation to blocks, nested blocks and peer blocks

Blocks are pieces of code that follows a method invocation and are delimited by  `do..end` or curly braces. They create an inner scope.
Inner scope can access and change variables initialized in an outer scope, but not vice versa. 
Nested blocks create nested scopes and obey the same outer/inner scope rules as variables.
Peer blocks do not conflict as they have their own scope and cannot reference variables initialized in another block.

```ruby
# local variable scope in relation to blocks
name = "Ivan"
1.times do |counter|
	name << " the terrible"
end
puts name # outputs Ivan the terrible
puts counter # NameError as counter cannot be referenced in the outer scope as it was initialized in an inner scope

# nested blocks
result = 0
2.times do |num|
	result += num
	puts nested_num # NameError as the outer scope cannot reference inner scope
	2.times do |nested_num|
		result += nested_num
		puts num
	end
end
puts result

# peer blocks
2.times do |num|
	puts num
end

2.times do |counter|
	puts num # NameError as num was initialized in another peer block
end
```

## Scope of constants


## Mutating values vs. reassigning variables


## Method definition vs. method invocation


## Passing and using blocks with methods


## Parameters vs. Arguments


## Default parameters


## Implicit vs. explicit return values


## Mutating vs. non-mutating methods

## Using method return values as arguments to other methods


## Mutable vs. immutable data types

## Output vs. return

## Pass-by-reference vs. pass-by-value

## Truthiness



In RB101, a "concept" refers to a fundamental programming principle or idea that you're learning and applying. These are the building blocks of programming that you'll use to solve problems and write code. Some key concepts in RB101 include:1.  Variables and data types  
2.  Control flow (if/else statements, loops)  
3.  Methods and return values  
4.  Arrays and hashes  
5.  Iteration and blocks  
6.  Variable scope  
7.  Mutability and immutability  
8.  Truthiness  
9.  Object passing (pass by reference vs. pass by value)Understanding these concepts means being able to recognize them in code, explain how they work, and use them effectively in your own programming. As you progress through RB101, you'll encounter these concepts repeatedly, each time gaining a deeper understanding of how they function and how to apply them in different situations.

there are indeed sub-concepts within the key concepts in RB101. Here are some important ones:
1.  Variables and Data Types:  
    •   Local variables  
    •   Constants  
    •   Type conversion
    2.  Control Flow:  
    •   Ternary operators  
    •   Case statements
    3.  Methods:  
    •   Method definition and invocation  
    •   Default parameters  
    •   Explicit and implicit return
    4.  Arrays and Hashes:  
    •   Array and hash methods  
    •   Nested collections
    5.  Iteration and Blocks:  
    •   Each, map, select methods  
    •   Block parameters
    6.  Variable Scope:  
    •   Method scope  
    •   Block scope  
    •   Shadowing
    7.  Mutability:  
    •   Destructive vs. non-destructive methods
    8.  Truthiness:  
    •   Falsey values (false and nil)  
    •   Short-circuit evaluation
    9.  Object Passing:  
    •   Object ids  
    •   Variable reassignment vs. mutation