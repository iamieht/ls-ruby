# Concepts

## Variables as Pointers

Variables act as pointers which references objects in memory and are not deeply linked to each other. 

```ruby
num1 = 5
num2 = num1
num1 = 10

puts num1 # 10
puts num2 # 5
```
## Variable Shadowing

It happens when a block parameter has the same name as a local variable initialized in an outer scope, preventing access and modification to the outer scope variable from within the block.

```ruby
result = 0

2.times do |result|
  result += 1
end

puts result
```

## Local variable scope in relation to method definitions

Methods have self-contained scope, meaning that only variables initialized inside the method or defined as parameters can be accessed inside the method. The only way to make the outer scope available to the method is via parameters.

```ruby
name = "Ivan"

def change_name(name)
	name = "Ivan the terrible"
end

puts change_name(name)
puts name
```


## Local variable scope in relation to blocks, nested blocks and peer blocks

Blocks are pieces of code that follows a method invocation and are delimited by  `do..end` or curly braces. They create an inner scope.
Inner scope can access and change variables initialized in an outer scope, but not vice versa. 
Nested blocks create nested scopes and obey the same outer/inner scope rules as variables.
Peer blocks do not conflict as they have their own scope and cannot reference variables initialized in another block.

```ruby
# local variable scope in relation to blocks
name = "Ivan"
1.times do |counter|
	name << " the terrible"
end
puts name # outputs Ivan the terrible
puts counter # NameError as counter cannot be referenced in the outer scope as it was initialized in an inner scope

# nested blocks
result = 0
2.times do |num|
	result += num
	puts nested_num # NameError as the outer scope cannot reference inner scope
	2.times do |nested_num|
		result += nested_num
		puts num
	end
end
puts result

# peer blocks
2.times do |num|
	puts num
end

2.times do |counter|
	puts num # NameError as num was initialized in another peer block
end
```

## Scope of constants

Constants have a lexical scope, meaning that they are available throughout the entire program, regardless of where they are defined.

```ruby
MY_CONSTANT = 100
# Rule 1: Constants can be access by methods
def output_constant 
  puts MY_CONSTANT
end

output_constant # 100

#Rule 2: Constants can be accessed by method invocation with a block
2.times do |counter|
	puts "Outputting #{MY_CONSTANT} #{counter + 1} time(s)"
end

# Rule 3: Constants initialized in an inner scope can be accessed in the outer scope
1.times do
	CONSTANT = "I am a constant"
end

puts CONSTANT

```
## Mutating values vs. reassigning variables

### Mutation: 

1. Modifies the existing object that the variable(s) points to.
2. Changes the object in place.
3. Keeps the same object ID.

```ruby
str = "I am the original String object"
puts "#{str} with object ID #{str.object_id}"
str.gsub!("original", "mutated")
puts "#{str} with object ID #{str.object_id}"
```

### Reassignment:

1. Creates a new object and points the variable to it.
2. Does not change the original object.
3. Non-mutating operation.

```ruby
str = "I am the original String object"
puts "#{str} with object ID #{str.object_id}"
str = "I am a new String object"
puts "#{str} with object ID #{str.object_id}"
```

## Method definition vs. method invocation

1. Method definition is when we define a method with the `def` keyword
2. Method invocation is when we call a method (and pass arguments to it)

```ruby
def message(message) # method definition
	puts message
end

message("Hola") # method invocation
```

## Passing and using blocks with methods

Any method can be called with a block, but the block is only executed if the method is defined in a particular way (`yield` keyword). The block act as an argument to the method invocation.

```ruby
# Block not executed

def greetings
  puts "Goodbye"
end

word = "Hello"

greetings do
  puts word
end

# Outputs 'Goodbye'

# Block executed
def greetings
  yield
  puts "Goodbye"
end

word = "Hello"

greetings do
  puts word
end

# Outputs 'Hello'
# Outputs 'Goodbye'
```

## Parameters vs. Arguments

**Parameters** are variables in a method definition or block that act as placeholders for values.

**Arguments** are the actual values passed to a method when it's called.

```ruby
def greet(name)
    puts "Hello, #{name}!"
end

greet("Ivan")
```


## Default parameters

Are default values assigned to the method parameters. If an argument isn't provided for a parameter with a default value, the default value will be used.

```ruby
def output_numbers(a, b = 2, c = 3)
    puts "#{a}, #{b}, #{c}"
end

output_numbers(1)
```


## Implicit vs. explicit return values

**Implicit return:**
	1. Ruby methods automatically return the value of the last executed expression.
	
```ruby
def add(a, b)
    a + b
end

puts add(3, 5)
```


**Explicit return:**
	1. Uses the `return` keyword to specify the return value.
	2. Can be used to return early from a method.
	3. The `return` keyword immediately exits the method, returning the specified value.
	4. Multiple values can be return by the return keyword (`return 1, 2, 3`)

```ruby
def check_positive(number)
    return false if number <= 0
    true
end
```


## Mutating vs. non-mutating methods

1. **Mutating methods:**
	1. Change the original object they're called on or passed to
	2. Often end with a bang (!) but not always
	3. Examples: `Array#push`, `Array#<<`, `String#upcase!`
2. **Non-mutating methods:**
	1. Return a new object, leaving the original unchanged
	2. Do not modify the object they're called on
	3. Examples: `String#upcase`, `Array#map`, `String#+`

1.  **"Mutates the caller"**: This means the method changes the object it's called on. For example, if you have an array and call a method that adds an element to it, the original array is modified.
2.  **"Mutates the arguments"**: This means the method changes the objects passed to it as arguments.
3. **"Change the value in that object's address space"**: This refers to modifying the actual object in memory, rather than creating a new object.

```ruby
def mutate(arr)
  arr.pop
end

def not_mutate(arr)
  arr.select { |i| i > 3 }
end

a = [1, 2, 3, 4, 5, 6]
mutate(a)
not_mutate(a)

puts a
```

## Using method return values as arguments to other methods

Every expression and method in Ruby returns a value, which can be used as an argument to another method invocation.

```ruby
# Using the return value of String#upcase as an argument to puts
puts "hello".upcase

# Using the return value of Array#join as an argument to puts
puts [1, 2, 3].join(", ")

# Using the return value of Integer#to_s as an argument to String#reverse
puts 12345.to_s.reverse

# Using the return value of one method as an argument to another method
def add_five(num)
  num + 5
end

def multiply_by_two(num)
  num * 2
end

result = multiply_by_two(add_five(10))
puts result  # Output: 30

# Chaining multiple methods
puts "hello world".split.map(&:capitalize).join(' ')
```
## Mutable vs. immutable data types

* Immutable types in Ruby include numbers, booleans (true and false), nil, and symbols. Strings and arrays are mutable.
* For a data type to be immutable means that its value cannot be changed after it is created. Any operation on an immutable object returns a new object rather than modifying the original. Mutable types, on the other hand, can be modified in place after creation.
* Some mutable types in Ruby include arrays, hashes, and custom objects.

## Output vs. return

1. Return values:
	1. Every method in Ruby returns a value, even if not explicitly specified.
	2. The last evaluated expression in a method is automatically returned.
	3. You can use the `return` keyword to explicitly return a value earlier in a method.
2. Output:
	1. The `puts` method is commonly used to output text to the console.
	2. `puts` automatically adds a newline after the output.
	3. `puts` always returns `nil`, regardless of what it outputs.
3. Difference between return and output:
	1. Return values are used within your program logic, while output is for displaying information to the user.
	2. A method can both return a value and produce output, but it's generally better to separate these concerns.
4. Best practices:
	1. Methods should generally either return a meaningful value or have a side effect (like output), but not both.
	2. Name methods that output values with prefixes like `print_`, `say_`, or `display_` to make their purpose clear.
5. Checking return values:
	1. You can use `p` instead of `puts` to both output a value and see its return value.
	2. In IRB (Interactive Ruby), the return value of each expression is automatically displayed.

### Key Points on Block's return and output

1. Return values:
	1. The last evaluated expression in a block is implicitly returned.
	2. You can use the `return` keyword to explicitly return a value from a block, but this is uncommon.
2. Output:
	1. Blocks can contain `puts` or `print` statements to output information.
	2. Output from a block is separate from its return value.
3. Block return values and method behavior:
	1. Many Ruby methods that take blocks (like `each`, `map`, `select`) use the block's return value in different ways.
	2. For example, `map` creates a new array based on the block's return values, while `select` uses the truthiness of the block's return value to filter elements.
4. Accessing block return values:
	1. The method that yields to the block can capture and use the block's return value.
	2. For example, the `yield` keyword returns the value of the block.
5. Side effects vs return values:
	1. It's generally better for blocks to either have side effects (like printing) or return a value, but not both.
	2. This makes the block's purpose clearer and easier to understand.

## Pass-by-reference vs. pass-by-value

Ruby always behaves as pass by value of the reference. That means that Ruby always passes a copy of the reference, which is not the object itself, but a reference to the object. So inside the method, whatever happens to that object, could mean one of two things: **either** Ruby behaves as if "pass-by-value" when the actions on that object won't mutate it (or if the object is immutable) **or** Ruby behaves as if "pass-by-reference" when the object is mutated.

```ruby
def change_string(str)
  str.upcase!  # This modifies the original string
  str = "new string"  # This reassignment doesn't affect the original
end
gi
s = "hello"
change_string(s)
puts s  # Outputs: HELLO
```

## Truthiness

* Truthy and falsy values refer to how Ruby evaluates different values in a boolean context.
* Ruby considers everything to be truthy (evaluates as true) other than the two falsy values, `false` and `nil`. 
* Truthiness differs from the boolean values `true` and `false`.
* Logical operators will return either a truthy or falsy value when evaluating two expressions.

In Ruby, truthiness affects conditional statements and logical operators (`&&` and `||`) in the following ways:

1. Conditional statements: 
	- Any value that is not `false` or `nil` is considered truthy in a conditional.
	- This means that even `0`, empty strings, and empty arrays are considered truthy.
  2. Logical AND (`&&`) operator: 
	    - Returns the first falsy operand if there is one.
	    - If all operands are truthy, it returns the last operand.
	    - Short-circuits: stops evaluating as soon as it encounters a falsy value.
3.  Logical OR (`||`) operator:  
	- Returns the first truthy operand if there is one.
	- If all operands are falsy, it returns the last operand.
	- Short-circuits: stops evaluating as soon as it encounters a truthy value.
	-
```ruby
def has_value?
      true
end

if has_value?
   puts "Has a value"
else
    puts "No value"
end
```

