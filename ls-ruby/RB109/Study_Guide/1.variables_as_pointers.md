# Variables as Pointers

A variable doesn't contain **a value**, instead it **contains a pointer to a physical space in memory** that contains the **value**. 

## Examples

### Case 1

```ruby
a = "hi there"
b = a
a = "not here"
```

![[Pasted image 20240625075004.png]]

The code `a = "not here"` reassigned the variable `a` to a different address in memory, so pointing to a new string. That is what the `=` operator does.

```ruby
puts "The variable a == #{a} with Object Id: #{a.object_id}"
puts "The variable b == #{b} with Object Id: #{b.object_id}"
```

```shell
The variable a == not there with Object Id: 60
The variable b == hi there with Object Id: 80
```

[[18.methods#`object_id`| object_id]] 

### Case 2

```ruby
a = "hi there"
b = a
a << ", Bob"
```

![[Pasted image 20240625081632.png]]

The code `a << ", Bob` did not reassigned `a` to a new string. Instead, it mutated the caller and modified the existing string, which is also pointed to by the variable `b`. 

**Important**: some operations mutate the address space, while others make the variable point to a different address space. Pay attention to whether the variables are pointing to the same object (address space) or if they are dealing with copies that occupy different address spaces.

This behavior applies to variables that points to arrays, hashes, or any data structure that has methods that mutates the caller or one or more of its arguments.

