# Variables as Pointers

A variable doesn't contain **a value**, instead it **contains a pointer to a physical space in memory** that contains the **value**. 

## Examples

### Case 1

```ruby
a = "hi there"
b = a
a = "not here"
```

![[Pasted image 20240625075004.png]]

The code `a = "not here"` reassigned the variable `a` to a different address in memory, so pointing to a new string. That is what the `=` operator does.

```ruby
puts "The variable a == #{a} with Object Id: #{a.object_id}"
puts "The variable b == #{b} with Object Id: #{b.object_id}"
```

```shell
The variable a == not there with Object Id: 60
The variable b == hi there with Object Id: 80
```

[[18.methods#`object_id`| object_id]] 

### Case 2

```ruby
a = "hi there"
b = a
a << ", Bob"
```

![[Pasted image 20240625081632.png]]

The code `a << ", Bob` did not reassigned `a` to a new string. Instead, it mutated the caller and modified the existing string, which is also pointed to by the variable `b`. 

**Important**: some operations mutate the address space, while others make the variable point to a different address space. Pay attention to whether the variables are pointing to the same object (address space) or if they are dealing with copies that occupy different address spaces.

This behavior applies to variables that points to arrays, hashes, or any data structure that has methods that mutates the caller or one or more of its arguments.

### Case 3

```ruby
a = [1, 2, 3, 3]
b = a
c = a.uniq

puts "a = #{a} Object id: #{a.object_id}"
puts "b = #{b} Object id: #{b.object_id}"
puts "c = #{c} Object id: #{c.object_id}"
```

What are `a`, `b` and `c`? 

```shell
a = [1, 2, 3, 3] Object id: 60
b = [1, 2, 3, 3] Object id: 60
c = [1, 2, 3] Object id: 80
```

What if the last line was `c = a.uniq!`?

`uniq!` is a destructive method, meaning it mutates the caller. In this case the object referenced by the 3 variables is the same.

```ruby
a = [1, 2, 3, 3]
b = a
c = a.uniq!

puts "a = #{a} Object id: #{a.object_id}"
puts "b = #{b} Object id: #{b.object_id}"
puts "c = #{c} Object id: #{c.object_id}"
```

```shell
a = [1, 2, 3] Object id: 60
b = [1, 2, 3] Object id: 60
c = [1, 2, 3] Object id: 60
```
### Case 4

```ruby
def test(b)
	b.map {|letter| "I like the letter: #{letter}"}
end

a = ['a', 'b', 'c']
test(a)
```

What is `a` after the `test` method returns? Did the method modify the value of `a`? Suppose we called `map!` instead of `map` from within `test`. Would that have any effect on the value of `a`?

```shell
a = ["a", "b", "c"]
```

`a` is not modified because the value of the original variable is assigned to the variable `b` inside the method `test` and since there are no operations that mutates the original value of `a` inside the method, the object referenced by `a` remains the same.

```ruby
def test(b)
	b.map! {|letter| "I like the letter: #{letter}"}
end

a = ['a', 'b', 'c']
test(a)
```

```shell
["I like the letter: a", "I like the letter: b", "I like the letter: c"]
```

The `map!` method mutates the caller, so the value referenced by the object `a` is mutated within the method `test`. 

**Important**: when we use variables to pass arguments to a method, we are assigning the value of the original variable (`a`) to a variable inside the method (`b`), which is equivalent to executing `b = a`. Inside the method, the operations we perform on the `b` variable determine whether the value of `b` will change. Some operations mutate the caller, some operations create new objects.