# Variables as Pointers

A variable doesn't contain **a value**, instead it **contains a pointer to a physical space in memory** that contains the **value**. 

## Examples

### Case 1

```ruby
a = "hi there"
b = a
a = "not here"
```

![[Pasted image 20240625075004.png]]

The code `a = "not here"` reassigned the variable `a` to a different address in memory, so pointing to a new string. That is what the `=` operator does.

```ruby
puts "The variable a == #{a} with Object Id: #{a.object_id}"
puts "The variable b == #{b} with Object Id: #{b.object_id}"
```

```shell
The variable a == not there with Object Id: 60
The variable b == hi there with Object Id: 80
```

[[18.methods#`object_id`| object_id]] 

### Case 2

```ruby
a = "hi there"
b = a
a << ", Bob"
```

![[Pasted image 20240625081632.png]]

The code `a << ", Bob` did not reassigned `a` to a new string. Instead, it mutated the caller and modified the existing string, which is also pointed to by the variable `b`. 

**Important**: some operations mutate the address space, while others make the variable point to a different address space. Pay attention to whether the variables are pointing to the same object (address space) or if they are dealing with copies that occupy different address spaces.

This behavior applies to variables that points to arrays, hashes, or any data structure that has methods that mutates the caller or one or more of its arguments.

### Case 3

```ruby
a = [1, 2, 3, 3]
b = a
c = a.uniq
```

What are `a`, `b` and `c`? What if the last line was `c = a.uniq!`?
### Case 4

```ruby
def test(b)
	b.map {|letter| "I like the letter: #{letter}"}
end

a = ['a', 'b', 'c']
test(a)
```

What is `a` after the `test` method returns? Did the method modify the value of `a`? Suppose we called `map!` instead of `map` from within `test`. Would that have any effect on the value of `a`?

**Important**: when we use variables to pass arguments to a method, we are assigning the value of the original variable (`a`) to a variable inside the method (`b`), which is equivalent to executing `b = a`. Inside the method, the operations we perform on the `b` variable determine whether the value of `b` will change. Some operations mutate the caller, some operations create new objects.